/*******************************************************************
* A coffee dispenser with water consumption control and simple GUI, 
* inspired in the initial version available at:
* http://useocl.sourceforge.net/w/index.php/Protocol_State_Machines
* 
* Author: Fernando Brito e Abreu, May 2019
*******************************************************************/
model InteractiveCoffeeDispenser
  
enum CoffeeType {RISTRETTO, ESPRESSO, LUNGO}
 

/****************************************************/
class GUI
	
	operations

		banner(message: String, spaces: Integer)
			begin
				for i in OrderedSet{1..spaces} do
					WriteLine('')
				end;
				WriteLine('*****************************************');
				WriteLine('* ' + message);
				WriteLine('*****************************************')
			end
		
		main(menus: Boolean, debug: Boolean)
			begin
				self.banner('Welcome to the QUASAR coffee machine!', 30);
				
				if self.dispenser.isUndefined() then
					insert (self, new CoffeeDispenser()) into GUI_CoffeeDispenser
				end;
				
				if menus then
					self.main_menu(debug)
				else
					self.main_simulation(debug)
				end;
				
				self.banner('Hope to have you back here soon!', 3)
			end

			
		/* Main program using a simulation with random values */ 
		main_simulation(debug: Boolean)
			begin
				declare
					seed: Integer,
					rgen: Random,
					clients: Integer,
					coins: Integer,
					coin_position: Integer,
					value: Integer,
					coffee_kind: Integer;
							
				Write('Enter a random seed number between 1 and 100 to start simulation > ');
				seed := ReadInteger();
				
				rgen:= new Random();
				rgen.init(seed);
				
				clients:= rgen.nextInteger(10,20);
				for client in OrderedSet{1..clients} do

					coins:= rgen.nextInteger(1,6);
						
					if debug then
						WriteLine('\n===============================================');
						WriteLine('Client ' + client.toString() + '/' + clients.toString() + ' has ' + coins.toString() + ' coin(s)!');
						WriteLine('===============================================');
						self.print_debug('')
					end;
						
					for coin in OrderedSet{1..coins} do
						
						if self.dispenser.oclInState(UNAVAILABLE) then
							self.dispenser.fill();
							if debug then
								self.print_debug('Executed fill() operation')		
							end
						end;
					
						coin_position:= rgen.nextInteger(1, self.dispenser.VALID_COINS->size);
						value:= self.dispenser.VALID_COINS->at(coin_position);
						self.dispenser.accept(value);
						if debug then
							self.print_debug('Executed accept(' + value.toString() + ') operation')
						end;

						if self.dispenser.oclInState(ENOUGH_COINS) then
							coffee_kind:= rgen.nextInteger(1,3);
							self.dispenser.brew(self.dispenser.COFFEE_TYPES->at(coffee_kind).type);
							if debug then
								self.print_debug('Executed brew(' + self.dispenser.COFFEE_TYPES->at(coffee_kind).name + ') operation')
							end
						end
					end;
					
					if not self.dispenser.oclInState(NO_COINS) then
						self.dispenser.returnChange();
						if debug then
							self.print_debug('Executed returnChange() operation')
						end
					end;

					if client < clients then
						self.pause('Push <enter> to proceed to next client')
					end
				end
			end
			
		/*	This operation causes a delay in the simulation; depending on the speed of
			your microprocessor, adjust the multiplying factor (currently 1000) */
		sleep(cycles: Integer)
			begin
				for t in OrderedSet{1..1000*cycles} do
				end
			end
			
		pause(message: String)
			begin
				Write(message);
				ReadLine()
			end
			
		print_debug(message: String)
			begin
				WriteLine(message);
				self.dispenser.printState();
				self.sleep(20)
			end
				
		/* Main program using menus */
		main_menu(debug: Boolean)
			begin
				declare 
					exit_menu: Boolean,
					option: Integer;
				
				exit_menu:= false;
				
				if debug then
					self.dispenser.printState()
				end;
				
				WriteLine('________________________________');			
				WriteLine('Choose an option:');
				if not self.dispenser.oclInState(UNAVAILABLE) then
					WriteLine('\t' + '1 (Add coin)');
				end;				
				if not self.dispenser.oclInState(NO_COINS) then
					WriteLine('\t' + '2 (Return change)');
				end;
				if self.dispenser.oclInState(ENOUGH_COINS) then
					WriteLine('\t' + '3 (Brew coffees)');
				end;
				WriteLine('\t' + '4 (Fill water deposit)');
				WriteLine('\t' + '0 (Exit menu)');
				Write('\nOption: ');

				option := ReadInteger();

				if option = 1 then
					self.accept_menu()
				else 
					if option = 2 then
						self.dispenser.returnChange()
					else 
						if option = 3 then
							self.brew_menu()
						else 
							if option = 4 then
								self.dispenser.fill()
							else 
								if option = 0 then
									exit_menu := true
								else
									WriteLine('Invalid option!')
								end
							end
						end
					end
				end;

				if exit_menu then
					if self.dispenser.clientAmount <> 0 then
						WriteLine('\n\nDo not forget to take your change (' +  self.dispenser.clientAmount.toString() + ' cents)');					
						self.dispenser.returnChange()
					end
				else
					self.main_menu(debug)
				end
			end
		
		/* Menu for accepting valid coins */			
		accept_menu()
			begin
				declare amount: Integer;

				Write('\nCoin to add (in cents): ');
				amount := ReadInteger();
				if self.dispenser.VALID_COINS->includes(amount) then			
					self.dispenser.accept(amount)
				else
					Write('Error: valid values are ');
					for value in self.dispenser.VALID_COINS do
						Write(value.toString() + ' ')
					end;
					WriteLine(' cents!');
					self.accept_menu()
				end
			end
			
		/* Menu for brewing different types of coffees */	
		brew_menu()
			begin
				declare 
					exit_menu: Boolean,
					option: Integer;
				
				exit_menu:= true;
				
				WriteLine('\nChoose the coffee type:');
				for t in self.dispenser.COFFEE_TYPES do		
					WriteLine('\t' + self.dispenser.COFFEE_TYPES->indexOf(t).toString()
							+' (' + t.name + ' - ' + t.volume.toString() + 'ml)');
				end;		
				WriteLine('\t' + '0 (Exit menu)');
				Write('\nOption: ');

				option := ReadInteger();

				if Set{1,2,3}->includes(option) then
					self.dispenser.brew(self.dispenser.COFFEE_TYPES->at(option).type)
				else 
					if option = 0 then
						WriteLine('No coffee brewed!')
					else
						WriteLine('Invalid option!');
						exit_menu := false
					end
				end;

				if not exit_menu then
					self.brew_menu()
				end
			end

end -- of class GUI




